generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Product {
  id                        Int             @id @default(autoincrement())
  title                     String
  slug                      String          @unique
  description               String
  category                  String
  inStock                   Boolean         @default(true)
  createdAt                 DateTime        @default(now())
  updatedAt                 DateTime        @updatedAt
  images                    String[]
  subCategory               String?
  pricePiece                Float?
  priceQuantity             Float?
  saleType                  String          @default("piece")
  availableQuantity         Int             @default(0)
  dimensions                String?
  minStockAlert             Int             @default(0)
  productId                 String?
  shippingWeight            String?
  status                    String          @default("Active")
  tags                      String[]
  variants                  Json?
  nouveautesUntil           DateTime?
  venteFlashActive          Boolean         @default(false)
  venteFlashPercentage      Int?
  venteFlashPrice           Float?
  shippingPrice             Float           @default(7)
  combinations              Json?
  flashApplyAllCombinations Boolean         @default(true)
  flashApplyTarget          String          @default("product")
  flashCombinationIds       String[]        @default([])
  flashDiscountType         String?         @default("percent")
  flashDiscountValue        Float?
  flashEndAt                DateTime?
  flashStartAt              DateTime?
  publishAt                 DateTime?
  visible                   Boolean         @default(true)
  minOrderQtyRetail         Int             @default(1)
  minOrderQtyWholesale      Int             @default(1)
  items                     OrderItem[]
  ratings                   ProductRating[]

  @@index([category])    // For category listing
  @@index([status])      // For filtering active products
  @@index([createdAt])   // For "newest" sorting
}

model Client {
  id           Int      @id @default(autoincrement())
  name         String?
  email        String?  @unique
  phone        String?
  createdAt    DateTime @default(now())
  purchaseUnit String   @default("piece")
  updatedAt    DateTime @updatedAt
  clerkId      String?  @unique
  orders       Order[]
}

model User {
  id           Int        @id @default(autoincrement())
  name         String?
  email        String?    @unique
  phone        String?    @unique
  passwordHash String
  role         Role       @default(CUSTOMER)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  employees    Employee[]
}

model Order {
  id                Int             @id @default(autoincrement())
  clientId          Int?
  total             Float
  status            String          @default("pending")
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  address           String?
  email             String?
  name              String?
  phone             String?
  paymentMethod     String?
  region            String?
  paidAt            DateTime?
  paymentStatus     String          @default("pending")
  providerPaymentId String?         @unique
  stockConsumed     Boolean         @default(false)
  
  // Cancellation tracking fields
  cancelReason      String?         // Required reason when order is canceled
  canceledAt        DateTime?       // Timestamp when order was canceled
  canceledBy        String?         // 'admin' | 'customer' | 'system'
  
  notifications     Notification[]
  client            Client?         @relation(fields: [clientId], references: [id])
  items             OrderItem[]
  PaymentSession    PaymentSession?

  @@index([email])       // For /orders/me queries
  @@index([status])      // For filtering orders by status
  @@index([createdAt])   // For sorting orders
}

model OrderItem {
  id         Int     @id @default(autoincrement())
  orderId    Int
  productId  Int
  quantity   Int
  price      Float
  attributes Json?
  color      String?
  size       String?
  variant    String?
  order      Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product    Product @relation(fields: [productId], references: [id], onDelete: Cascade)
}

model Notification {
  id        Int              @id @default(autoincrement())
  type      NotificationType @default(ORDER)
  title     String
  message   String?
  payload   Json?
  read      Boolean          @default(false)
  recipient String?
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  orderId   Int?
  order     Order?           @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([recipient])
  @@index([read])
  @@index([createdAt])
}

model Employee {
  id           Int      @id @default(autoincrement())
  fullName     String
  email        String?  @unique
  phone        String?  @unique
  role         Role
  isActive     Boolean  @default(true)
  linkedUserId Int?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  linkedUser   User?    @relation(fields: [linkedUserId], references: [id])
  
  // Task relations
  assignedTasks    Task[]           @relation("TaskAssignee")
  createdTasks     Task[]           @relation("TaskCreator")
  taskCompletions  TaskCompletion[]
}

model VisitorCount {
  id        BigInt   @id @default(autoincrement())
  total     BigInt   @default(0)
  createdAt DateTime @default(now()) @map("created_at")

  @@map("visitor_count")
}

model VisitorDailyStat {
  id        BigInt   @id @default(autoincrement())
  day       DateTime @unique @db.Date
  total     BigInt   @default(0)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("visitor_daily_stats")
}

model ProductRating {
  id          Int      @id @default(autoincrement())
  productId   Int
  rating      Int
  comment     String?
  authorName  String?
  authorEmail String?
  clerkUserId String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  product     Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([productId])
  @@index([clerkUserId])
}

/// *
/// * Cart - Database-backed cart for cross-device sync
/// * Uses Clerk ID for user identification
model Cart {
  id        Int        @id @default(autoincrement())
  clerkId   String     @unique
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  items     CartItem[]

  @@index([clerkId])
}

/// *
/// * CartItem - Individual cart items with price snapshots
/// * Stores snapshot data to prevent missing prices after schema changes
model CartItem {
  id            Int      @id @default(autoincrement())
  cartId        Int
  productId     Int
  combinationId String?
  quantity      Int
  unitType      String
  priceAtAdd    Float
  titleAtAdd    String
  imageAtAdd    String?
  optionsAtAdd  Json?
  minQty        Int?
  maxQty        Int?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  variantLabel  String?
  cart          Cart     @relation(fields: [cartId], references: [id], onDelete: Cascade)

  @@index([cartId])
  @@index([productId])
}

/// Wishlist - Database-backed wishlist for cross-device sync
/// Uses Clerk ID for user identification (like Cart)
model Wishlist {
  id        Int            @id @default(autoincrement())
  clerkId   String         @unique
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  items     WishlistItem[]

  @@index([clerkId])
}

/// WishlistItem - Individual wishlist items with price snapshots
model WishlistItem {
  id         Int      @id @default(autoincrement())
  wishlistId Int
  productId  Int
  priceAtAdd Float
  titleAtAdd String
  imageAtAdd String?
  createdAt  DateTime @default(now())
  wishlist   Wishlist @relation(fields: [wishlistId], references: [id], onDelete: Cascade)

  @@unique([wishlistId, productId])
  @@index([wishlistId])
}

/// Shop-wide settings (singleton row with id=1)
/// Stores free shipping threshold and default shipping fee
model ShopSettings {
  id                      Int      @id @default(1)
  freeShippingThresholdDt Float    @default(200)
  defaultShippingFeeDt    Float    @default(8)
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt
}

/// Store location for "Points de Vente" section in footer
model StoreLocation {
  id        Int      @id @default(autoincrement())
  name      String   // e.g., "Tunis Centre"
  address   String   // e.g., "15 Avenue Habib Bourguiba, Tunis"
  phone     String   // e.g., "+216 71 123 456"
  isActive  Boolean  @default(true)
  sortOrder Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model PaymentSession {
  id            Int      @id @default(autoincrement())
  token         String   @unique
  status        String   @default("pending")
  amount        Float
  items         Json
  customerName  String?
  customerEmail String?
  customerPhone String?
  address       String?
  region        String?
  paymentMethod String   @default("paymee_card")
  orderId       Int?     @unique
  expiresAt     DateTime
  createdAt     DateTime @default(now())
  updatedAt     DateTime
  Order         Order?   @relation(fields: [orderId], references: [id])

  @@index([expiresAt])
  @@index([status])
  @@index([token])
}

enum Role {
  ADMIN
  PRODUCT_MANAGER
  ORDER_MANAGER
  CUSTOMER
}

/// *
/// * Notifications
/// * - Keep notifications flexible with a payload Json field.
/// * - Link optionally to an Order using orderId + order relation.
/// * - Add indexes helpful for queries (recipient, read, createdAt).
enum NotificationType {
  ORDER
  SYSTEM
  INFO
}

// ============================================================
// Task Management Enums & Models
// ============================================================

enum TaskType {
  CALL
  MEETING
  MILESTONE
  TASK
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  COMPLETED
  CANCELED
}

enum RepeatRule {
  NONE
  DAILY
  WEEKLY
  MONTHLY
}

/// Task - Employee task/calendar event
model Task {
  id            String       @id @default(cuid())
  title         String
  description   String?
  type          TaskType     @default(TASK)
  category      String?      // "Orders", "Products", "Marketing", etc.
  priority      Int          @default(2) // 1=high, 2=medium, 3=low
  status        TaskStatus   @default(TODO)
  
  // Calendar fields
  startAt       DateTime?
  endAt         DateTime?
  dueAt         DateTime?    // deadline
  
  // Recurrence
  repeatRule    RepeatRule   @default(NONE)
  
  // Relations
  assignedToId  Int
  assignedTo    Employee     @relation("TaskAssignee", fields: [assignedToId], references: [id])
  
  createdById   Int
  createdBy     Employee     @relation("TaskCreator", fields: [createdById], references: [id])
  
  completions   TaskCompletion[]
  
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  
  @@index([assignedToId])
  @@index([status])
  @@index([startAt])
  @@index([dueAt])
}

/// TaskCompletion - Completion report for a task occurrence
model TaskCompletion {
  id              String    @id @default(cuid())
  
  taskId          String
  task            Task      @relation(fields: [taskId], references: [id], onDelete: Cascade)
  
  completedById   Int
  completedBy     Employee  @relation(fields: [completedById], references: [id])
  
  occurrenceDate  DateTime  // which day's instance was completed (for recurring tasks)
  completedAt     DateTime  @default(now())
  reportText      String    // required completion report
  timeSpentMin    Int?
  blockers        String?
  
  @@unique([taskId, completedById, occurrenceDate])
  @@index([completedById])
  @@index([completedAt])
}
